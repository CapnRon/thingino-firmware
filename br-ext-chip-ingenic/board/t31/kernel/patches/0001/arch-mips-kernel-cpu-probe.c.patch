
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -17,6 +17,7 @@
 #include <linux/smp.h>
 #include <linux/stddef.h>
 #include <linux/export.h>
+#include <linux/kallsyms.h>
 
 #include <asm/bugs.h>
 #include <asm/cpu.h>
@@ -75,6 +76,8 @@ void __init check_bugs32(void)
 	check_errata();
 }
 
+#include <asm/pgtable.h>
+#include <asm/bootinfo.h>
 /*
  * Probe whether cpu has config register by trying to play with
  * alternate cache bit and see whether it matters.
@@ -117,6 +120,22 @@ static inline unsigned long cpu_get_fpu_id(void)
 	return fpu_id;
 }
 
+/*
+ * Set and Get the FPU CSR31.
+ */
+static inline unsigned long cpu_test_fpu_csr31(unsigned long fcr31)
+{
+	unsigned long tmp;
+
+	tmp = read_c0_status();
+	__enable_fpu();
+	write_32bit_cp1_register(CP1_STATUS,fcr31);
+	enable_fpu_hazard();
+	fcr31 = read_32bit_cp1_register(CP1_STATUS);
+	write_c0_status(tmp);
+	return fcr31;
+}
+
 /*
  * Check the CPU has an FPU the official way.
  */
@@ -174,6 +193,8 @@ static inline unsigned int decode_config0(struct cpuinfo_mips *c)
 
 	if (((config0 & MIPS_CONF_MT) >> 7) == 1)
 		c->options |= MIPS_CPU_TLB;
+	if (((config0 & MIPS_CONF_MT) >> 7) == 4)
+		c->options |= MIPS_CPU_TLB;
 	isa = (config0 & MIPS_CONF_AT) >> 13;
 	switch (isa) {
 	case 0:
@@ -196,8 +217,6 @@ static inline unsigned int decode_config0(struct cpuinfo_mips *c)
 		case 1:
 			set_isa(c, MIPS_CPU_ISA_M64R2);
 			break;
-		default:
-			goto unknown;
 		}
 		break;
 	default:
@@ -228,8 +247,11 @@ static inline unsigned int decode_config1(struct cpuinfo_mips *c)
 		c->options |= MIPS_CPU_FPU;
 		c->options |= MIPS_CPU_32FPR;
 	}
-	if (cpu_has_tlb)
+	if (cpu_has_tlb) {
 		c->tlbsize = ((config1 & MIPS_CONF1_TLBS) >> 25) + 1;
+		c->tlbsizevtlb = c->tlbsize;
+		c->tlbsizeftlbsets = 0;
+	}
 
 	return config1 & MIPS_CONF_M;
 }
@@ -254,10 +276,14 @@ static inline unsigned int decode_config3(struct cpuinfo_mips *c)
 
 	if (config3 & MIPS_CONF3_SM) {
 		c->ases |= MIPS_ASE_SMARTMIPS;
+#if defined(CONFIG_64BIT) || !defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
 		c->options |= MIPS_CPU_RIXI;
+#endif
 	}
+#if defined(CONFIG_64BIT) || !defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
 	if (config3 & MIPS_CONF3_RXI)
 		c->options |= MIPS_CPU_RIXI;
+#endif
 	if (config3 & MIPS_CONF3_DSP)
 		c->ases |= MIPS_ASE_DSP;
 	if (config3 & MIPS_CONF3_DSP2P)
@@ -272,33 +298,127 @@ static inline unsigned int decode_config3(struct cpuinfo_mips *c)
 		c->options |= MIPS_CPU_ULRI;
 	if (config3 & MIPS_CONF3_ISA)
 		c->options |= MIPS_CPU_MICROMIPS;
-#ifdef CONFIG_CPU_MICROMIPS
-	write_c0_config3(read_c0_config3() | MIPS_CONF3_ISA_OE);
-#endif
 	if (config3 & MIPS_CONF3_VZ)
 		c->ases |= MIPS_ASE_VZ;
+	if (config3 & MIPS_CONF3_SC)
+		c->options |= MIPS_CPU_SEGMENTS;
 
 	return config3 & MIPS_CONF_M;
 }
 
-static inline unsigned int decode_config4(struct cpuinfo_mips *c)
+static unsigned int cpu_capability = 0;
+
+static inline unsigned int decode_config4(struct cpuinfo_mips *c, int pass,
+					  int conf6available)
 {
 	unsigned int config4;
+	unsigned int newcf4;
+	unsigned int config6;
 
 	config4 = read_c0_config4();
 
-	if ((config4 & MIPS_CONF4_MMUEXTDEF) == MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT
-	    && cpu_has_tlb)
-		c->tlbsize += (config4 & MIPS_CONF4_MMUSIZEEXT) * 0x40;
+	if (pass && cpu_has_tlb) {
+		if (config4 & MIPS_CONF4_IE) {
+			if (config4 & MIPS_CONF4_TLBINV) {
+				c->options |= MIPS_CPU_TLBINV;
+				printk("TLBINV/F supported, config4=0x%0x\n",config4);
+			}
+			/* TBW: page walker support starts here */
+		}
+		switch (config4 & MIPS_CONF4_MMUEXTDEF) {
+		case MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT:
+			c->tlbsize =
+			    ((((config4 & MIPS_CONF4_MMUSIZEEXT) >>
+			       MIPS_CONF4_MMUSIZEEXT_SHIFT) <<
+			      MIPS_CONF1_TLBS_SIZE) |
+				(c->tlbsize - 1)) + 1;
+			c->tlbsizevtlb = c->tlbsize;
+			printk("MMUSizeExt found, total TLB=%d\n",c->tlbsize);
+			break;
+		case MIPS_CONF4_MMUEXTDEF_VTLBSIZEEXT:
+			c->tlbsizevtlb = ((c->tlbsizevtlb - 1) |
+				(((config4 & MIPS_CONF4_VTLBSIZEEXT) >>
+				  MIPS_CONF4_VTLBSIZEEXT_SHIFT) <<
+				 MIPS_CONF1_TLBS_SIZE)) + 1;
+			c->tlbsize = c->tlbsizevtlb;
+			/* fall through */
+		case MIPS_CONF4_MMUEXTDEF_FTLBSIZEEXT:
+			newcf4 = (config4 & ~MIPS_CONF4_FTLBPAGESIZE) |
+				((((fls(PAGE_SIZE >> BASIC_PAGE_SHIFT)-1)/2)+1) <<
+				 MIPS_CONF4_FTLBPAGESIZE_SHIFT);
+			write_c0_config4(newcf4);
+			back_to_back_c0_hazard();
+			config4 = read_c0_config4();
+			if (config4 != newcf4) {
+				printk(KERN_ERR "PAGE_SIZE 0x%0lx is not supported by FTLB (config4=0x%0x)\n",
+					PAGE_SIZE, config4);
+				if (conf6available && (cpu_capability & MIPS_FTLB_CAPABLE)) {
+					printk("Switching FTLB OFF\n");
+					config6 = read_c0_config6();
+					write_c0_config6(config6 & ~MIPS_CONF6_FTLBEN);
+				}
+				printk("Total TLB(VTLB) inuse: %d\n",c->tlbsizevtlb);
+				break;
+			}
+			c->tlbsizeftlbsets = 1 <<
+				((config4 & MIPS_CONF4_FTLBSETS) >>
+				 MIPS_CONF4_FTLBSETS_SHIFT);
+			c->tlbsizeftlbways = ((config4 & MIPS_CONF4_FTLBWAYS) >>
+					      MIPS_CONF4_FTLBWAYS_SHIFT) + 2;
+			c->tlbsize += (c->tlbsizeftlbways *
+				       c->tlbsizeftlbsets);
+			printk("V/FTLB found: VTLB=%d, FTLB sets=%d, ways=%d total TLB=%d\n",
+				c->tlbsizevtlb, c->tlbsizeftlbsets, c->tlbsizeftlbways, c->tlbsize);
+			break;
+		}
+	}
 
 	c->kscratch_mask = (config4 >> 16) & 0xff;
 
 	return config4 & MIPS_CONF_M;
 }
 
-static void __cpuinit decode_configs(struct cpuinfo_mips *c)
+static inline unsigned int decode_config5(struct cpuinfo_mips *c)
+{
+	unsigned int config5;
+
+	config5 = read_c0_config5();
+
+	if (config5 & MIPS_CONF5_EVA)
+		c->options |= MIPS_CPU_EVA;
+
+	return config5 & MIPS_CONF_M;
+}
+
+static inline unsigned int decode_config6_ftlb(struct cpuinfo_mips *c)
 {
-	int ok;
+	unsigned int config6;
+
+	if (cpu_capability & MIPS_FTLB_CAPABLE) {
+
+		/*
+		 * Can't rely on mips_ftlb_disabled since kernel command line
+		 * hasn't been processed yet.  Need to peek at the raw command
+		 * line for "noftlb".
+		 */
+		if (strstr(arcs_cmdline, "noftlb") == NULL) {
+			config6 = read_c0_config6();
+
+			printk("Enable FTLB attempt\n");
+			write_c0_config6(config6 | MIPS_CONF6_FTLBEN);
+			back_to_back_c0_hazard();
+
+			return(1);
+		}
+	}
+
+	return(0);
+}
+
+
+static void decode_configs(struct cpuinfo_mips *c)
+{
+	int ok, ok3 = 0, ok6 = 0;
 
 	/* MIPS32 or MIPS64 compliant CPU.  */
 	c->options = MIPS_CPU_4KEX | MIPS_CPU_4K_CACHE | MIPS_CPU_COUNTER |
@@ -307,15 +427,22 @@ static void __cpuinit decode_configs(struct cpuinfo_mips *c)
 	c->scache.flags = MIPS_CACHE_NOT_PRESENT;
 
 	ok = decode_config0(c);			/* Read Config registers.  */
-	BUG_ON(!ok);				/* Arch spec violation!	 */
+	BUG_ON(!ok);				/* Arch spec violation!  */
 	if (ok)
 		ok = decode_config1(c);
 	if (ok)
 		ok = decode_config2(c);
 	if (ok)
-		ok = decode_config3(c);
+		ok = ok3 = decode_config3(c);
+	if (ok)
+		ok = decode_config4(c,0,0);   /* first pass - just return Mbit */
 	if (ok)
-		ok = decode_config4(c);
+		ok = decode_config5(c);
+	if (cpu_capability & MIPS_FTLB_CAPABLE)
+		ok6 = decode_config6_ftlb(c);
+
+	if (ok3)
+		ok = decode_config4(c,1,ok6); /* real parse pass, thanks HW team :-/ */
 
 	mips_probe_watch_registers(c);
 
@@ -712,7 +839,26 @@ static inline void cpu_probe_mips(struct cpuinfo_mips *c, unsigned int cpu)
 		c->cputype = CPU_74K;
 		__cpu_name[cpu] = "MIPS 1074Kc";
 		break;
+	case PRID_IMP_PROAPTIV_UP:
+		c->cputype = CPU_PROAPTIV;
+		__cpu_name[cpu] = "MIPS proAptiv";
+		cpu_capability = MIPS_FTLB_CAPABLE;
+		break;
+	case PRID_IMP_PROAPTIV_MP:
+		c->cputype = CPU_PROAPTIV;
+		__cpu_name[cpu] = "MIPS proAptiv (multi)";
+		cpu_capability = MIPS_FTLB_CAPABLE;
+		break;
+	case PRID_IMP_INTERAPTIV_UP:
+		c->cputype = CPU_INTERAPTIV;
+		__cpu_name[cpu] = "MIPS interAptiv UP";
+		break;
+	case PRID_IMP_INTERAPTIV_MP:
+		c->cputype = CPU_INTERAPTIV;
+		__cpu_name[cpu] = "MIPS interAptiv";
+		break;
 	}
+	decode_configs(c);
 
 	spram_config();
 }
@@ -872,19 +1018,49 @@ platform:
 	}
 }
 
+extern int soc_support_mxuv2(void);
+
 static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
 {
+	unsigned int errorpc;
+	static unsigned int showerrorpc[NR_CPUS];
+	unsigned int config1;
+
+	if(showerrorpc[cpu] == 0) {
+		__asm__ __volatile__ (
+			"mfc0  %0, $30,  0   \n\t"
+			"nop                  \n\t"
+			:"=r"(errorpc)
+			:);
+
+		printk("CPU%d RESET ERROR PC:%08X\n", cpu,errorpc);
+		if(kernel_text_address(errorpc))
+			print_ip_sym(errorpc);
+		showerrorpc[cpu] = 1;
+	}
 	decode_configs(c);
 	/* JZRISC does not implement the CP0 counter. */
 	c->options &= ~MIPS_CPU_COUNTER;
-	switch (c->processor_id & 0xff00) {
-	case PRID_IMP_JZRISC:
-		c->cputype = CPU_JZRISC;
-		__cpu_name[cpu] = "Ingenic JZRISC";
-		break;
-	default:
-		panic("Unknown Ingenic Processor ID!");
-		break;
+
+	c->cputype = CPU_JZRISC;
+	__cpu_name[cpu] = "Ingenic Xburst";
+	c->isa_level = MIPS_CPU_ISA_M32R1;
+	c->tlbsize = 32;
+
+	config1 = read_c0_config1();
+
+	/* Xburst CU2 is MXUV2 */
+	if (config1 & MIPS_CONF1_C2) {
+		if (soc_support_mxuv2()) {
+			c->ases |= MIPS_ASE_XBURSTMXUV2;
+		} else {
+			c->ases |= MIPS_ASE_XBURSTMXU;
+		}
+	}
+
+	__write_32bit_c0_register($16, 7, 0x10);
+	if((c->processor_id & PRID_CPU_ISA_MASK) == PRID_IMP_ISA_R2) {
+		c->isa_level = MIPS_CPU_ISA_M32R2;
 	}
 }
 
@@ -969,6 +1145,8 @@ EXPORT_SYMBOL(__ua_limit);
 
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
+unsigned int fpu_fcr31 __read_mostly = 0;
+unsigned int system_has_fpu __read_mostly = 0;
 
 __cpuinit void cpu_probe(void)
 {
@@ -1011,6 +1189,9 @@ __cpuinit void cpu_probe(void)
 	case PRID_COMP_NETLOGIC:
 		cpu_probe_netlogic(c, cpu);
 		break;
+	default:
+		cpu_probe_ingenic(c, cpu);
+		break;
 	}
 
 	BUG_ON(!__cpu_name[cpu]);
@@ -1030,12 +1211,17 @@ __cpuinit void cpu_probe(void)
 		c->ases &= ~(MIPS_ASE_DSP | MIPS_ASE_DSP2P);
 
 	if (c->options & MIPS_CPU_FPU) {
+		system_has_fpu = 1;
+		fpu_fcr31 = cpu_test_fpu_csr31(FPU_CSR_DEFAULT);
+
 		c->fpu_id = cpu_get_fpu_id();
 
 		if (c->isa_level & (MIPS_CPU_ISA_M32R1 | MIPS_CPU_ISA_M32R2 |
 				    MIPS_CPU_ISA_M64R1 | MIPS_CPU_ISA_M64R2)) {
 			if (c->fpu_id & MIPS_FPIR_3D)
 				c->ases |= MIPS_ASE_MIPS3D;
+			if (c->fpu_id & MIPS_FPIR_HAS2008)
+				fpu_fcr31 = cpu_test_fpu_csr31(FPU_CSR_DEFAULT|FPU_CSR_MAC2008|FPU_CSR_ABS2008|FPU_CSR_NAN2008);
 		}
 	}
 
@@ -1059,8 +1245,8 @@ __cpuinit void cpu_report(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 
-	printk(KERN_INFO "CPU revision is: %08x (%s)\n",
-	       c->processor_id, cpu_name_string());
+	printk(KERN_INFO "CPU%d revision is: %08x (%s)\n",
+	       smp_processor_id(), c->processor_id, cpu_name_string());
 	if (c->options & MIPS_CPU_FPU)
 		printk(KERN_INFO "FPU revision is: %08x\n", c->fpu_id);
 }
