
--- a/arch/mips/include/asm/r4kcache.h
+++ b/arch/mips/include/asm/r4kcache.h
@@ -16,7 +16,30 @@
 #include <asm/cacheops.h>
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
-
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_JZRISC
+
+#define INVALIDATE_BTB()			\
+do {						\
+	unsigned long tmp;			\
+	__asm__ __volatile__(			\
+	"	.set mips32		\n"	\
+	"	mfc0 %0, $16, 7		\n"	\
+	"	nop			\n"	\
+	"	ori %0, 2		\n"	\
+	"	mtc0 %0, $16, 7		\n"	\
+	"	nop			\n"	\
+	: "=&r" (tmp));				\
+} while (0)
+#define SYNC_WB() __sync()
+
+#else /* CONFIG_JZRISC */
+
+#define INVALIDATE_BTB() do { } while (0)
+#define SYNC_WB() do { } while (0)
+
+#endif /* CONFIG_JZRISC */
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -28,7 +51,9 @@
  *  - We need a properly sign extended address for 64-bit code.	 To get away
  *    without ifdefs we let the compiler do it by a type cast.
  */
-#define INDEX_BASE	CKSEG0
+#ifndef INDEX_BASE
+#define INDEX_BASE      CKSEG0
+#endif
 
 #define cache_op(op,addr)						\
 	__asm__ __volatile__(						\
@@ -127,6 +152,19 @@ extern void mt_cflush_release(void);
 
 #else /* CONFIG_MIPS_MT */
 
+#ifdef CONFIG_JZRISC
+#define __iflush_prologue
+#define __iflush_epilogue	INVALIDATE_BTB();
+#define __dflush_prologue
+#define __dflush_epilogue	SYNC_WB();
+#define __inv_dflush_prologue
+#define __inv_dflush_epilogue	SYNC_WB();
+#define __sflush_prologue {
+#define __sflush_epilogue }
+#define __inv_sflush_prologue {
+#define __inv_sflush_epilogue }
+
+#else
 #define __iflush_prologue {
 #define __iflush_epilogue }
 #define __dflush_prologue {
@@ -138,6 +176,8 @@ extern void mt_cflush_release(void);
 #define __inv_sflush_prologue {
 #define __inv_sflush_epilogue }
 
+#endif /* !CONFIG_JZRISC */
+
 #endif /* CONFIG_MIPS_MT */
 
 static inline void flush_icache_line_indexed(unsigned long addr)
@@ -203,12 +243,34 @@ static inline void flush_scache_line(unsigned long addr)
 	:							\
 	: "i" (op), "r" (addr))
 
+#ifdef CONFIG_EVA
+#define protected_cachee_op(op,addr)                            \
+	__asm__ __volatile__(					\
+	"	.set	push			\n"		\
+	"	.set	noreorder		\n"		\
+	"       .set    eva                     \n"             \
+	"1:     cachee  %0, (%1)                \n"             \
+	"2:	.set	pop			\n"		\
+	"	.section __ex_table,\"a\"	\n"		\
+	"	"STR(PTR)" 1b, 2b		\n"		\
+	"	.previous"					\
+	:							\
+	: "i" (op), "r" (addr))
+#endif
+
 /*
  * The next two are for badland addresses like signal trampolines.
  */
 static inline void protected_flush_icache_line(unsigned long addr)
 {
+#ifndef CONFIG_EVA
 	protected_cache_op(Hit_Invalidate_I, addr);
+#else
+	protected_cachee_op(Hit_Invalidate_I, addr);
+#endif
+#ifdef CONFIG_JZRISC
+	INVALIDATE_BTB();
+#endif
 }
 
 /*
@@ -219,7 +281,14 @@ static inline void protected_flush_icache_line(unsigned long addr)
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
+#ifndef CONFIG_EVA
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
+#else
+	protected_cachee_op(Hit_Writeback_Inv_D, addr);
+#endif
+#ifdef CONFIG_JZRISC
+	SYNC_WB();
+#endif
 }
 
 static inline void protected_writeback_scache_line(unsigned long addr)
@@ -339,6 +408,112 @@ static inline void invalidate_tcache_page(unsigned long addr)
 		: "r" (base),						\
 		  "i" (op));
 
+#ifdef CONFIG_EVA
+#define cache16_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x010(%0)      \n"     \
+	"       cachee %1, 0x020(%0); cachee %1, 0x030(%0)      \n"     \
+	"       cachee %1, 0x040(%0); cachee %1, 0x050(%0)      \n"     \
+	"       cachee %1, 0x060(%0); cachee %1, 0x070(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x090(%0)      \n"     \
+	"       cachee %1, 0x0a0(%0); cachee %1, 0x0b0(%0)      \n"     \
+	"       cachee %1, 0x0c0(%0); cachee %1, 0x0d0(%0)      \n"     \
+	"       cachee %1, 0x0e0(%0); cachee %1, 0x0f0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x110(%0)      \n"     \
+	"       cachee %1, 0x120(%0); cachee %1, 0x130(%0)      \n"     \
+	"       cachee %1, 0x140(%0); cachee %1, 0x150(%0)      \n"     \
+	"       cachee %1, 0x160(%0); cachee %1, 0x170(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x190(%0)      \n"     \
+	"       cachee %1, 0x1a0(%0); cachee %1, 0x1b0(%0)      \n"     \
+	"       cachee %1, 0x1c0(%0); cachee %1, 0x1d0(%0)      \n"     \
+	"       cachee %1, 0x1e0(%0); cachee %1, 0x1f0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache32_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x020(%0)      \n"     \
+	"       cachee %1, 0x040(%0); cachee %1, 0x060(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x0a0(%0)      \n"     \
+	"       cachee %1, 0x0c0(%0); cachee %1, 0x0e0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x120(%0)      \n"     \
+	"       cachee %1, 0x140(%0); cachee %1, 0x160(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x1a0(%0)      \n"     \
+	"       cachee %1, 0x1c0(%0); cachee %1, 0x1e0(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x220(%0)      \n"     \
+	"       cachee %1, 0x240(%0); cachee %1, 0x260(%0)      \n"     \
+	"       cachee %1, 0x280(%0); cachee %1, 0x2a0(%0)      \n"     \
+	"       cachee %1, 0x2c0(%0); cachee %1, 0x2e0(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x320(%0)      \n"     \
+	"       cachee %1, 0x340(%0); cachee %1, 0x360(%0)      \n"     \
+	"       cachee %1, 0x380(%0); cachee %1, 0x3a0(%0)      \n"     \
+	"       cachee %1, 0x3c0(%0); cachee %1, 0x3e0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache64_unroll32_user(base,op)                                  \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x040(%0)      \n"     \
+	"       cachee %1, 0x080(%0); cachee %1, 0x0c0(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x140(%0)      \n"     \
+	"       cachee %1, 0x180(%0); cachee %1, 0x1c0(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x240(%0)      \n"     \
+	"       cachee %1, 0x280(%0); cachee %1, 0x2c0(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x340(%0)      \n"     \
+	"       cachee %1, 0x380(%0); cachee %1, 0x3c0(%0)      \n"     \
+	"       cachee %1, 0x400(%0); cachee %1, 0x440(%0)      \n"     \
+	"       cachee %1, 0x480(%0); cachee %1, 0x4c0(%0)      \n"     \
+	"       cachee %1, 0x500(%0); cachee %1, 0x540(%0)      \n"     \
+	"       cachee %1, 0x580(%0); cachee %1, 0x5c0(%0)      \n"     \
+	"       cachee %1, 0x600(%0); cachee %1, 0x640(%0)      \n"     \
+	"       cachee %1, 0x680(%0); cachee %1, 0x6c0(%0)      \n"     \
+	"       cachee %1, 0x700(%0); cachee %1, 0x740(%0)      \n"     \
+	"       cachee %1, 0x780(%0); cachee %1, 0x7c0(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache128_unroll32_user(base,op)                                 \
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"       .set eva                                        \n"     \
+	"       cachee %1, 0x000(%0); cachee %1, 0x080(%0)      \n"     \
+	"       cachee %1, 0x100(%0); cachee %1, 0x180(%0)      \n"     \
+	"       cachee %1, 0x200(%0); cachee %1, 0x280(%0)      \n"     \
+	"       cachee %1, 0x300(%0); cachee %1, 0x380(%0)      \n"     \
+	"       cachee %1, 0x400(%0); cachee %1, 0x480(%0)      \n"     \
+	"       cachee %1, 0x500(%0); cachee %1, 0x580(%0)      \n"     \
+	"       cachee %1, 0x600(%0); cachee %1, 0x680(%0)      \n"     \
+	"       cachee %1, 0x700(%0); cachee %1, 0x780(%0)      \n"     \
+	"       cachee %1, 0x800(%0); cachee %1, 0x880(%0)      \n"     \
+	"       cachee %1, 0x900(%0); cachee %1, 0x980(%0)      \n"     \
+	"       cachee %1, 0xa00(%0); cachee %1, 0xa80(%0)      \n"     \
+	"       cachee %1, 0xb00(%0); cachee %1, 0xb80(%0)      \n"     \
+	"       cachee %1, 0xc00(%0); cachee %1, 0xc80(%0)      \n"     \
+	"       cachee %1, 0xd00(%0); cachee %1, 0xd80(%0)      \n"     \
+	"       cachee %1, 0xe00(%0); cachee %1, 0xe80(%0)      \n"     \
+	"       cachee %1, 0xf00(%0); cachee %1, 0xf80(%0)      \n"     \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+#endif
+
 /* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
 #define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
 static inline void blast_##pfx##cache##lsize(void)			\
@@ -411,6 +586,33 @@ __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
 
+#ifdef CONFIG_EVA
+
+#define __BUILD_BLAST_USER_CACHE(pfx, desc, indexop, hitop, lsize) \
+static inline void blast_##pfx##cache##lsize##_user_page(unsigned long page) \
+{									\
+	unsigned long start = page;					\
+	unsigned long end = page + PAGE_SIZE;				\
+									\
+	__##pfx##flush_prologue						\
+									\
+	do {								\
+		cache##lsize##_unroll32_user(start, hitop);             \
+		start += lsize * 32;					\
+	} while (start < end);						\
+									\
+	__##pfx##flush_epilogue						\
+}
+
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
+__BUILD_BLAST_USER_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
+__BUILD_BLAST_USER_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
+
+#endif
+
 /* build blast_xxx_range, protected_blast_xxx_range */
 #define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
@@ -423,7 +625,7 @@ static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 	__##pfx##flush_prologue						\
 									\
 	while (1) {							\
-		prot##cache_op(hitop, addr);				\
+		prot##cache_op(hitop, addr);                            \
 		if (addr == aend)					\
 			break;						\
 		addr += lsize;						\
@@ -432,10 +634,49 @@ static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 	__##pfx##flush_epilogue						\
 }
 
+#ifndef CONFIG_EVA
+
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
 __BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
+
+#else
+
+#define __BUILD_PROT_BLAST_CACHE_RANGE(pfx, desc, hitop)                \
+static inline void protected_blast_##pfx##cache##_range(unsigned long start, \
+						    unsigned long end)	\
+{									\
+	unsigned long lsize = cpu_##desc##_line_size();			\
+	unsigned long addr = start & ~(lsize - 1);			\
+	unsigned long aend = (end - 1) & ~(lsize - 1);			\
+									\
+	__##pfx##flush_prologue						\
+									\
+	if (segment_eq(get_fs(), USER_DS))                              \
+		while (1) {                                             \
+			protected_cachee_op(hitop, addr);               \
+			if (addr == aend)                               \
+				break;                                  \
+			addr += lsize;                                  \
+		}                                                       \
+	else                                                            \
+		while (1) {                                             \
+			protected_cache_op(hitop, addr);                \
+			if (addr == aend)                               \
+				break;                                  \
+			addr += lsize;                                  \
+		}                                                       \
+									\
+	__##pfx##flush_epilogue						\
+}
+
+__BUILD_PROT_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D)
+__BUILD_PROT_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I)
+
+#endif
+
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
+__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, )
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
 /* blast_inv_dcache_range */
 __BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
