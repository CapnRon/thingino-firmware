
--- a/arch/mips/include/asm/switch_to.h
+++ b/arch/mips/include/asm/switch_to.h
@@ -15,8 +15,8 @@
 #include <asm/cpu-features.h>
 #include <asm/watch.h>
 #include <asm/dsp.h>
-
-struct task_struct;
+#include <mxu.h>
+#include <asm/cop2.h>
 
 /*
  * switch_to(n) should switch tasks to task nr n, first
@@ -24,6 +24,16 @@ struct task_struct;
  */
 extern asmlinkage void *resume(void *last, void *next, void *next_ti, u32 __usedfpu);
 
+#ifdef CONFIG_PMON_DEBUG
+extern void save_perf_event_jz(void *tskvoid);
+extern void restore_perf_event_jz(void *tskvoid);
+#else
+#define save_perf_event_jz(tskvoid)
+#define restore_perf_event_jz(tskvoid)
+#endif
+
+struct task_struct;
+
 extern unsigned int ll_bit;
 extern struct task_struct *ll_task;
 
@@ -67,9 +77,21 @@ do {									\
 #define switch_to(prev, next, last)					\
 do {									\
 	u32 __usedfpu;							\
+	u32 __c0_stat;							\
 	__mips_mt_fpaff_switch_to(prev);				\
 	if (cpu_has_dsp)						\
 		__save_dsp(prev);					\
+	if (cpu_has_mxu)						\
+		__save_mxu(prev);					\
+	if (cop2_present && (KSTK_STATUS(prev) & ST0_CU2)) {		\
+		if (cop2_lazy_restore)					\
+			KSTK_STATUS(prev) &= ~ST0_CU2;			\
+		__c0_stat = read_c0_status();				\
+		write_c0_status(__c0_stat | ST0_CU2);			\
+		cop2_save(&prev->thread.cp2);				\
+		write_c0_status(__c0_stat & ~ST0_CU2);			\
+	}								\
+	save_perf_event_jz(prev);					\
 	__clear_software_ll_bit();					\
 	__usedfpu = test_and_clear_tsk_thread_flag(prev, TIF_USEDFPU);	\
 	(last) = resume(prev, next, task_thread_info(next), __usedfpu); \
@@ -77,10 +99,21 @@ do {									\
 
 #define finish_arch_switch(prev)					\
 do {									\
+	u32 __c0_stat;							\
+	if (cop2_present && !cop2_lazy_restore &&			\
+			(KSTK_STATUS(current) & ST0_CU2)) {		\
+		__c0_stat = read_c0_status();				\
+		write_c0_status(__c0_stat | ST0_CU2);			\
+		cop2_restore(&current->thread.cp2);			\
+		write_c0_status(__c0_stat & ~ST0_CU2);			\
+	}								\
 	if (cpu_has_dsp)						\
 		__restore_dsp(current);					\
 	if (cpu_has_userlocal)						\
 		write_c0_userlocal(current_thread_info()->tp_value);	\
+	if (cpu_has_mxu)                                                \
+		__restore_mxu(current); 				\
+	restore_perf_event_jz(current);					\
 	__restore_watch();						\
 } while (0)
 
